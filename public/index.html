<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Library Manager</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f0f2f5;
            height: 100vh;
            overflow: hidden;
        }

        .top-bar {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 50px;
        }

        .top-bar h1 {
            font-size: 1.2em;
        }

        .stats-inline {
            display: flex;
            gap: 20px;
            font-size: 13px;
        }

        .stats-inline .stat {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .stats-inline .stat-num {
            font-weight: 700;
            font-size: 16px;
        }

        /* Three-panel layout */
        .app-container {
            display: flex;
            height: calc(100vh - 50px);
            transition: all 0.3s ease;
        }

        .panel {
            transition: all 0.3s ease;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            background: white;
            border-right: 1px solid #e0e0e0;
        }

        .panel:last-child {
            border-right: none;
        }

        .panel-header {
            padding: 12px 16px;
            background: #f8f9fa;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            min-height: 48px;
            flex-shrink: 0;
        }

        .panel-header h2 {
            font-size: 14px;
            color: #333;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
        }

        /* Panel states */
        .library-panel {
            flex: 0 0 70%;
            min-width: 200px;
        }

        .book-panel {
            flex: 0 0 0%;
            min-width: 0;
            opacity: 0;
            padding: 0;
        }

        .book-panel.visible {
            flex: 0 0 50%;
            min-width: 300px;
            opacity: 1;
        }

        .chat-panel {
            flex: 0 0 30%;
            min-width: 280px;
        }

        /* State: Book selected */
        .app-container.book-selected .library-panel {
            flex: 0 0 15%;
            min-width: 60px;
        }

        .app-container.book-selected .book-panel {
            flex: 0 0 50%;
            min-width: 300px;
            opacity: 1;
        }

        .app-container.book-selected .chat-panel {
            flex: 0 0 35%;
        }

        /* State: Chat active */
        .app-container.chat-active .library-panel {
            flex: 0 0 15%;
            min-width: 60px;
        }

        .app-container.chat-active .book-panel {
            flex: 0 0 15%;
            min-width: 60px;
            opacity: 1;
        }

        .app-container.chat-active .chat-panel {
            flex: 0 0 70%;
        }

        /* State: Chat active without book */
        .app-container.chat-active-no-book .library-panel {
            flex: 0 0 30%;
        }

        .app-container.chat-active-no-book .book-panel {
            flex: 0 0 0%;
            min-width: 0;
            opacity: 0;
        }

        .app-container.chat-active-no-book .chat-panel {
            flex: 0 0 70%;
        }

        /* Minimized panel styles */
        .panel.minimized .panel-content {
            display: none;
        }

        .panel.minimized .panel-header {
            writing-mode: vertical-rl;
            text-orientation: mixed;
            padding: 16px 8px;
            cursor: pointer;
        }

        .panel.minimized .panel-header h2 {
            font-size: 12px;
        }

        .panel.minimized .panel-header .panel-actions {
            display: none;
        }

        /* Panel control buttons */
        .panel-btn {
            background: none;
            border: 1px solid #ddd;
            cursor: pointer;
            padding: 4px 8px;
            color: #666;
            font-size: 14px;
            border-radius: 4px;
            line-height: 1;
            min-width: 28px;
        }

        .panel-btn:hover {
            background: #f0f4ff;
            border-color: #667eea;
            color: #667eea;
        }

        .panel-btn.close-btn:hover {
            background: #fee;
            border-color: #dc3545;
            color: #dc3545;
        }

        .panel-btn.nav-btn {
            padding: 2px 6px;
            font-size: 12px;
            min-width: 24px;
        }

        .panel-btn.nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .panel-header-left {
            display: flex;
            align-items: center;
            gap: 6px;
            flex: 1;
            min-width: 0;
        }

        .panel-header-left h2 {
            flex: 1;
            min-width: 0;
        }

        /* Library panel specific */
        .controls {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        .controls.compact {
            flex-direction: column;
        }

        .controls.compact > * {
            width: 100%;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 8px 14px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: transform 0.2s, opacity 0.2s;
            white-space: nowrap;
        }

        button:hover {
            opacity: 0.9;
        }

        button.secondary {
            background: #6c757d;
            padding: 6px 10px;
        }

        button.small {
            padding: 4px 8px;
            font-size: 11px;
        }

        input, select, textarea {
            padding: 8px 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 12px;
            font-family: inherit;
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .filters-row {
            display: flex;
            gap: 6px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }

        .filters-row select {
            flex: 1;
            min-width: 80px;
        }

        .book-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 12px;
            padding: 4px;
        }

        .book-card {
            background: white;
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            display: flex;
            flex-direction: column;
            border: 2px solid transparent;
        }

        .book-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
        }

        .book-card.selected {
            border-color: #667eea;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        .book-cover {
            width: 100%;
            aspect-ratio: 2/3;
            background: linear-gradient(135deg, #f5f7fa 0%, #e4e8ec 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .book-cover img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .book-cover-placeholder {
            color: #999;
            font-size: 32px;
        }

        .book-info {
            padding: 8px;
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .book-card h3 {
            color: #333;
            margin: 0 0 4px 0;
            font-size: 12px;
            line-height: 1.3;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .book-card .author {
            color: #666;
            font-size: 10px;
            margin-bottom: 4px;
        }

        .book-card .bottom-row {
            margin-top: auto;
        }

        .status-badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 9px;
            font-weight: 600;
            text-transform: capitalize;
        }

        .status-completed { background: #d4edda; color: #155724; }
        .status-reading { background: #fff3cd; color: #856404; }
        .status-want-to-read { background: #d1ecf1; color: #0c5460; }
        .status-on-hold { background: #e2e3e5; color: #383d41; }

        /* Book panel specific */
        .book-detail-header {
            display: flex;
            gap: 16px;
            margin-bottom: 16px;
        }

        .book-detail-cover {
            width: 100px;
            height: 150px;
            object-fit: cover;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            flex-shrink: 0;
        }

        .book-detail-info h2 {
            margin: 0 0 8px 0;
            font-size: 16px;
        }

        .book-detail-info p {
            margin: 3px 0;
            font-size: 12px;
            color: #555;
        }

        .book-detail-info .tags {
            margin-top: 8px;
        }

        .book-detail-info .tag {
            display: inline-block;
            background: #e9ecef;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 10px;
            margin-right: 4px;
            margin-bottom: 4px;
        }

        .content-section {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 12px;
        }

        .content-section h3 {
            font-size: 13px;
            margin-bottom: 8px;
            color: #333;
        }

        .content-section p,
        .content-section .markdown-content {
            font-size: 12px;
            line-height: 1.6;
            color: #444;
        }

        .content-section .markdown-content p { margin-bottom: 8px; }
        .content-section .markdown-content p:last-child { margin-bottom: 0; }

        /* Book reference links in Q&A */
        .book-ref {
            cursor: pointer;
            border-bottom: 1px dashed #667eea;
            transition: all 0.2s;
        }

        .book-ref:hover {
            background: rgba(102, 126, 234, 0.1);
        }

        .book-ref.in-library {
            color: #667eea;
            font-weight: 500;
        }

        .book-ref.not-in-library {
            color: #28a745;
        }

        .book-ref-tooltip {
            position: absolute;
            background: #333;
            color: white;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 11px;
            z-index: 1000;
            white-space: nowrap;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .book-ref-tooltip.visible {
            opacity: 1;
        }

        .book-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .delete-btn {
            background: #dc3545;
        }

        /* Chat panel specific */
        .book-context-banner {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
        }

        .book-context-banner .book-title {
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 1;
        }

        .book-context-banner button {
            background: rgba(255,255,255,0.2);
            padding: 4px 10px;
            font-size: 10px;
            margin-left: 8px;
            flex-shrink: 0;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 6px;
            margin-bottom: 8px;
        }

        .message {
            margin-bottom: 10px;
            padding: 10px;
            border-radius: 6px;
            font-size: 12px;
            line-height: 1.5;
        }

        .message.user {
            background: #667eea;
            color: white;
            margin-left: 20px;
        }

        .message.assistant {
            background: white;
            margin-right: 20px;
            border: 1px solid #e0e0e0;
        }

        /* Markdown content styling */
        .message.assistant p { margin-bottom: 8px; }
        .message.assistant p:last-child { margin-bottom: 0; }
        .message.assistant ul, .message.assistant ol { margin: 8px 0; padding-left: 20px; }
        .message.assistant li { margin-bottom: 4px; }
        .message.assistant strong { font-weight: 600; }

        .suggestions-container {
            padding: 8px;
            background: #f0f4ff;
            border-radius: 6px;
            border-left: 3px solid #667eea;
            margin-bottom: 8px;
        }

        .suggestions-container h4 {
            font-size: 10px;
            color: #667eea;
            margin-bottom: 6px;
        }

        .suggestion-btn {
            display: block;
            width: 100%;
            text-align: left;
            background: white;
            color: #333;
            padding: 6px 10px;
            margin-bottom: 4px;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
        }

        .suggestion-btn:hover {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .suggestion-btn:last-child { margin-bottom: 0; }

        .chat-input {
            display: flex;
            gap: 6px;
        }

        .chat-input input {
            flex: 1;
        }

        .message-container {
            position: relative;
        }

        /* Loading and error states */
        .message.loading {
            background: #f8f9fa;
            border: 1px dashed #ccc;
            color: #666;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .typing-indicator {
            display: flex;
            gap: 4px;
            align-items: center;
        }

        .typing-indicator span {
            width: 6px;
            height: 6px;
            background: #667eea;
            border-radius: 50%;
            animation: typing 1.4s infinite ease-in-out;
        }

        .typing-indicator span:nth-child(1) { animation-delay: 0s; }
        .typing-indicator span:nth-child(2) { animation-delay: 0.2s; }
        .typing-indicator span:nth-child(3) { animation-delay: 0.4s; }

        @keyframes typing {
            0%, 60%, 100% { transform: translateY(0); opacity: 0.4; }
            30% { transform: translateY(-4px); opacity: 1; }
        }

        .message.error {
            background: #fee;
            border: 1px solid #fcc;
            color: #c33;
        }

        .message.error .retry-btn {
            background: #c33;
            color: white;
            border: none;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 10px;
            cursor: pointer;
            margin-left: 10px;
        }

        .chat-input button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .saved-qa-separator {
            display: flex;
            align-items: center;
            margin: 10px 0;
            color: #888;
            font-size: 10px;
        }

        .saved-qa-separator::before,
        .saved-qa-separator::after {
            content: '';
            flex: 1;
            height: 1px;
            background: #ddd;
        }

        .saved-qa-separator span {
            padding: 0 8px;
            white-space: nowrap;
        }

        /* Collapsible Q&A styles */
        .qa-item {
            margin-bottom: 6px;
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid #e0e0e0;
            background: white;
        }

        .qa-item.hidden-qa {
            opacity: 0.6;
            border-style: dashed;
        }

        .qa-header {
            display: flex;
            align-items: center;
            padding: 8px 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            cursor: pointer;
            gap: 8px;
            transition: background 0.2s;
        }

        .qa-header:hover {
            opacity: 0.95;
        }

        .qa-header .expand-icon {
            font-size: 10px;
            transition: transform 0.2s;
            flex-shrink: 0;
        }

        .qa-item.expanded .qa-header .expand-icon {
            transform: rotate(90deg);
        }

        .qa-header .question-text {
            flex: 1;
            font-size: 12px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .qa-item.expanded .qa-header .question-text {
            white-space: normal;
        }

        .qa-body {
            display: none;
            padding: 10px;
            background: #f8f9fa;
            font-size: 12px;
            line-height: 1.5;
        }

        .qa-item.expanded .qa-body {
            display: block;
        }

        .qa-body p { margin-bottom: 6px; }
        .qa-body p:last-child { margin-bottom: 0; }
        .qa-body ul, .qa-body ol { margin: 6px 0; padding-left: 18px; }
        .qa-body li { margin-bottom: 3px; }

        .qa-actions {
            display: flex;
            gap: 6px;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #e0e0e0;
        }

        .qa-actions button {
            padding: 4px 8px;
            font-size: 10px;
        }

        .qa-controls {
            display: flex;
            gap: 4px;
            margin-top: 6px;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .message-container:hover .qa-controls {
            opacity: 1;
        }

        .qa-controls button {
            padding: 2px 8px;
            font-size: 10px;
            background: #6c757d;
        }

        .qa-controls .hide-btn { background: #ffc107; color: #333; }
        .qa-controls .unhide-btn { background: #28a745; }
        .qa-controls .delete-btn { background: #dc3545; }

        .hidden-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 10px;
            background: #fff3cd;
            border-radius: 6px;
            margin-bottom: 8px;
            font-size: 11px;
            color: #856404;
        }

        .hidden-toggle button {
            padding: 4px 10px;
            font-size: 10px;
            background: #ffc107;
            color: #333;
        }

        /* Modal for add book */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal.active { display: flex; }

        .modal-content {
            background: white;
            padding: 24px;
            border-radius: 8px;
            max-width: 500px;
            max-height: 85vh;
            overflow-y: auto;
            width: 90%;
        }

        .modal-content h2 {
            margin-bottom: 16px;
            color: #333;
            font-size: 16px;
        }

        .modal-content input,
        .modal-content select {
            width: 100%;
            margin-bottom: 10px;
        }

        .close-modal {
            float: right;
            font-size: 24px;
            cursor: pointer;
            color: #999;
            line-height: 1;
        }

        .close-modal:hover { color: #333; }

        .loading-text {
            text-align: center;
            color: #666;
            padding: 20px;
            font-size: 12px;
        }

        /* Empty state for book panel */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #888;
            text-align: center;
            padding: 20px;
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 12px;
        }

        .empty-state p {
            font-size: 13px;
        }

        /* Saved Q&A section in book panel */
        .saved-qa-section {
            margin-top: 12px;
            border-top: 1px solid #e0e0e0;
            padding-top: 12px;
        }

        .saved-qa-section h3 {
            font-size: 13px;
            margin-bottom: 10px;
        }

        /* Genre Tree Dropdown */
        .genre-dropdown-container {
            position: relative;
            display: inline-block;
        }

        .genre-dropdown-btn {
            padding: 6px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
            cursor: pointer;
            font-size: 12px;
            min-width: 120px;
            text-align: left;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .genre-dropdown-btn:hover {
            border-color: #667eea;
        }

        .genre-dropdown-btn .arrow {
            margin-left: 8px;
            font-size: 10px;
        }

        .genre-tree {
            position: absolute;
            top: 100%;
            left: 0;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            min-width: 200px;
            max-height: 300px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }

        .genre-tree.open {
            display: block;
        }

        .genre-tree-item {
            cursor: pointer;
        }

        .genre-tree-header {
            padding: 8px 12px;
            font-weight: 500;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #f8f9fa;
            border-bottom: 1px solid #eee;
        }

        .genre-tree-header:hover {
            background: #e9ecef;
        }

        .genre-tree-header .expand-arrow {
            font-size: 10px;
            transition: transform 0.2s;
        }

        .genre-tree-item.expanded .genre-tree-header .expand-arrow {
            transform: rotate(90deg);
        }

        .genre-tree-subgenres {
            display: none;
            background: white;
        }

        .genre-tree-item.expanded .genre-tree-subgenres {
            display: block;
        }

        .genre-tree-subgenre {
            padding: 6px 12px 6px 24px;
            font-size: 12px;
            color: #555;
            border-bottom: 1px solid #f0f0f0;
        }

        .genre-tree-subgenre:hover {
            background: #f0f0ff;
            color: #667eea;
        }

        .genre-tree-all {
            padding: 8px 12px;
            font-weight: 500;
            border-bottom: 1px solid #ddd;
            background: white;
        }

        .genre-tree-all:hover {
            background: #f0f0ff;
            color: #667eea;
        }

        /* Settings Panel */
        .settings-btn {
            background: transparent;
            border: none;
            color: white;
            font-size: 18px;
            cursor: pointer;
            padding: 4px 8px;
            opacity: 0.8;
        }

        .settings-btn:hover {
            opacity: 1;
        }

        .settings-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        .settings-modal.active {
            display: flex;
        }

        .settings-content {
            background: white;
            border-radius: 8px;
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .settings-header {
            padding: 16px 20px;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #f8f9fa;
        }

        .settings-header h2 {
            font-size: 16px;
            margin: 0;
        }

        .settings-close {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: #666;
        }

        .settings-body {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
        }

        .settings-section {
            margin-bottom: 24px;
        }

        .settings-section h3 {
            font-size: 14px;
            margin-bottom: 12px;
            color: #333;
        }

        .taxonomy-editor {
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            overflow: hidden;
        }

        .taxonomy-genre {
            border-bottom: 1px solid #e0e0e0;
        }

        .taxonomy-genre:last-child {
            border-bottom: none;
        }

        .taxonomy-genre-header {
            padding: 10px 12px;
            background: #f8f9fa;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }

        .taxonomy-genre-header:hover {
            background: #e9ecef;
        }

        .taxonomy-genre-name {
            font-weight: 500;
            font-size: 13px;
        }

        .taxonomy-genre-actions {
            display: flex;
            gap: 4px;
        }

        .taxonomy-genre-actions button {
            padding: 2px 8px;
            font-size: 11px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }

        .taxonomy-genre-actions button.delete-btn {
            background: #dc3545;
        }

        .taxonomy-subgenres {
            padding: 8px 12px;
            display: none;
            flex-wrap: wrap;
            gap: 6px;
            background: white;
        }

        .taxonomy-genre.expanded .taxonomy-subgenres {
            display: flex;
        }

        .taxonomy-subgenre-tag {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            background: #e9ecef;
            border-radius: 4px;
            font-size: 12px;
        }

        .taxonomy-subgenre-tag .remove-btn {
            background: none;
            border: none;
            color: #999;
            cursor: pointer;
            font-size: 14px;
            padding: 0;
            line-height: 1;
        }

        .taxonomy-subgenre-tag .remove-btn:hover {
            color: #dc3545;
        }

        .taxonomy-add-subgenre {
            display: flex;
            gap: 4px;
            margin-top: 8px;
            padding: 0 12px 12px;
        }

        .taxonomy-add-subgenre input {
            flex: 1;
            padding: 4px 8px;
            font-size: 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .taxonomy-footer {
            padding: 12px;
            border-top: 1px solid #e0e0e0;
            display: flex;
            gap: 8px;
            justify-content: space-between;
        }

        .taxonomy-footer button {
            padding: 6px 12px;
            font-size: 12px;
            border-radius: 4px;
            cursor: pointer;
        }

        .taxonomy-footer .add-genre-btn {
            background: #667eea;
            color: white;
            border: none;
        }

        .taxonomy-footer .reset-btn {
            background: white;
            color: #666;
            border: 1px solid #ddd;
        }

        .settings-future {
            color: #888;
            font-size: 12px;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 6px;
        }

        .settings-future h4 {
            font-size: 12px;
            margin-bottom: 8px;
            color: #666;
        }

        .settings-future ul {
            margin: 0;
            padding-left: 20px;
        }

        .settings-future li {
            margin-bottom: 4px;
        }
    </style>
</head>
<body>
    <div class="top-bar">
        <h1>AI Library Manager</h1>
        <div class="stats-inline" id="stats"></div>
        <button class="settings-btn" onclick="openSettings()" title="Settings">âš™</button>
    </div>

    <div class="app-container" id="appContainer">
        <!-- Library Panel -->
        <div class="panel library-panel" id="libraryPanel">
            <div class="panel-header">
                <h2>Library</h2>
                <div class="panel-actions">
                    <button class="small" onclick="showAddBookModal()">+ Add</button>
                </div>
            </div>
            <div class="panel-content">
                <div class="controls" id="libraryControls">
                    <input type="text" id="searchInput" placeholder="Search..." style="flex: 1; min-width: 100px;" onkeypress="if(event.key==='Enter')searchBooks()">
                    <button class="small secondary" onclick="searchBooks()">Go</button>
                </div>
                <div class="filters-row" id="filtersRow">
                    <div class="genre-dropdown-container">
                        <button class="genre-dropdown-btn" onclick="toggleGenreDropdown(event)">
                            <span id="genreDropdownLabel">All Genres</span>
                            <span class="arrow">â–¼</span>
                        </button>
                        <div class="genre-tree" id="genreTree">
                            <div class="genre-tree-all" onclick="selectGenre(null, null, 'All Genres')">All Genres</div>
                            <!-- Populated by JavaScript -->
                        </div>
                    </div>
                    <select id="sortBy" onchange="applyFilters()">
                        <option value="publishedYear-desc">Published (Newest)</option>
                        <option value="publishedYear-asc">Published (Oldest)</option>
                        <option value="title-asc">Title (A-Z)</option>
                        <option value="title-desc">Title (Z-A)</option>
                        <option value="author-asc">Author (A-Z)</option>
                        <option value="author-desc">Author (Z-A)</option>
                        <option value="dateAdded-desc">Added (Recent)</option>
                        <option value="dateAdded-asc">Added (Oldest)</option>
                    </select>
                    <select id="filterStatus" onchange="applyFilters()">
                        <option value="">All Status</option>
                        <option value="want-to-read">Want to Read</option>
                        <option value="reading">Reading</option>
                        <option value="completed">Completed</option>
                        <option value="on-hold">On Hold</option>
                    </select>
                </div>
                <div class="book-grid" id="bookGrid"></div>
            </div>
        </div>

        <!-- Book Panel -->
        <div class="panel book-panel" id="bookPanel">
            <div class="panel-header">
                <div class="panel-header-left">
                    <button class="panel-btn nav-btn" onclick="goBackInHistory()" id="historyBackBtn" title="Previous book" disabled>&#x2190;</button>
                    <button class="panel-btn nav-btn" onclick="goForwardInHistory()" id="historyForwardBtn" title="Next book" disabled>&#x2192;</button>
                    <h2 id="bookPanelTitle">Book Details</h2>
                </div>
                <div class="panel-actions">
                    <button class="panel-btn" onclick="toggleBookPanelSize()" id="bookPanelToggle" title="Maximize">&#x26F6;</button>
                    <button class="panel-btn close-btn" onclick="closeBookPanel()" title="Close">&times;</button>
                </div>
            </div>
            <div class="panel-content" id="bookPanelContent">
                <div class="empty-state">
                    <div class="empty-state-icon">ðŸ“–</div>
                    <p>Select a book to view details</p>
                </div>
            </div>
        </div>

        <!-- Chat Panel -->
        <div class="panel chat-panel" id="chatPanel">
            <div class="panel-header">
                <h2>AI Assistant</h2>
                <div class="panel-actions">
                    <button class="panel-btn" onclick="toggleChatPanelSize()" id="chatPanelToggle" title="Maximize">&#x26F6;</button>
                </div>
            </div>
            <div class="panel-content" style="display: flex; flex-direction: column;">
                <div id="bookContextBanner" style="display: none;"></div>
                <div id="hiddenToggleContainer" style="display: none;"></div>
                <div class="chat-messages" id="chatMessages">
                    <div class="message assistant">
                        Select a book or ask me anything about your library.
                    </div>
                </div>
                <div id="suggestionsContainer"></div>
                <div class="chat-input">
                    <input type="text" id="chatInput" placeholder="Ask about your library..." onkeypress="handleChatKeyPress(event)">
                    <button onclick="sendMessage()">Send</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="settings-modal" id="settingsModal">
        <div class="settings-content">
            <div class="settings-header">
                <h2>Settings</h2>
                <button class="settings-close" onclick="closeSettings()">&times;</button>
            </div>
            <div class="settings-body">
                <div class="settings-section">
                    <h3>Genre Taxonomy</h3>
                    <p style="font-size: 12px; color: #666; margin-bottom: 12px;">
                        Organize your library with genres and sub-genres (tags). Click a genre to expand/edit.
                    </p>
                    <div class="taxonomy-editor" id="taxonomyEditor">
                        <!-- Populated by JavaScript -->
                    </div>
                    <div class="taxonomy-footer">
                        <button class="add-genre-btn" onclick="addNewGenre()">+ Add Genre</button>
                        <button class="reset-btn" onclick="regenerateTaxonomy()">Reset to Auto-Generated</button>
                    </div>
                </div>
                <div class="settings-section">
                    <div class="settings-future">
                        <h4>Coming Soon</h4>
                        <ul>
                            <li>Chat History</li>
                            <li>Books History</li>
                            <li>Data Export</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Add Book Modal -->
    <div class="modal" id="addBookModal">
        <div class="modal-content">
            <span class="close-modal" onclick="closeModal('addBookModal')">&times;</span>
            <h2>Add New Book</h2>
            <p style="color: #666; margin-bottom: 12px; font-size: 12px;">Enter title and author. We'll fetch metadata automatically.</p>
            <input type="text" id="title" placeholder="Title *" required>
            <input type="text" id="author" placeholder="Author *" required>
            <input type="text" id="isbn" placeholder="ISBN (optional)">
            <select id="status">
                <option value="want-to-read">Want to Read</option>
                <option value="reading">Reading</option>
                <option value="completed">Completed</option>
                <option value="on-hold">On Hold</option>
            </select>
            <input type="text" id="tags" placeholder="Tags (comma-separated, optional)">
            <div id="addBookStatus" style="margin: 10px 0; color: #666; font-size: 12px;"></div>
            <button onclick="addBook()">Add Book</button>
        </div>
    </div>

    <script>
        const API_BASE = 'http://localhost:3000/api';

        // Panel state management
        let currentState = 'initial'; // initial, book-selected, chat-active, chat-active-no-book
        let selectedBookId = null;
        let currentViewedBook = null;
        let currentBookContext = null;
        let showHiddenQA = false;
        let isProcessing = false;
        let lastQuestion = '';
        let lastAnswer = '';
        let lastSavedQAId = null;

        // Book history management - persisted in localStorage
        const MAX_BOOK_HISTORY = 10;
        const HISTORY_STORAGE_KEY = 'bookHistory';
        let bookHistory = []; // Array of book IDs
        let historyIndex = -1; // Current position in history
        let isNavigatingHistory = false; // Flag to prevent adding to history during navigation

        // Genre taxonomy state
        let currentTaxonomy = [];
        let selectedGenreTags = []; // Tags to filter by
        let selectedGenreLabel = 'All Genres';

        // Load history from localStorage
        function loadBookHistory() {
            try {
                const stored = localStorage.getItem(HISTORY_STORAGE_KEY);
                if (stored) {
                    const data = JSON.parse(stored);
                    bookHistory = data.history || [];
                    historyIndex = data.index >= 0 && data.index < bookHistory.length ? data.index : bookHistory.length - 1;
                }
            } catch (e) {
                console.error('Error loading book history:', e);
                bookHistory = [];
                historyIndex = -1;
            }
            updateHistoryButtons();
        }

        // Save history to localStorage
        function saveBookHistory() {
            try {
                localStorage.setItem(HISTORY_STORAGE_KEY, JSON.stringify({
                    history: bookHistory,
                    index: historyIndex
                }));
            } catch (e) {
                console.error('Error saving book history:', e);
            }
        }

        function setPanelState(state) {
            const container = document.getElementById('appContainer');
            container.classList.remove('book-selected', 'chat-active', 'chat-active-no-book');

            if (state !== 'initial') {
                container.classList.add(state);
            }
            currentState = state;

            // Update panel minimized states
            updatePanelMinimization();
        }

        function updatePanelMinimization() {
            const libraryPanel = document.getElementById('libraryPanel');
            const bookPanel = document.getElementById('bookPanel');

            // Check if panels should be minimized based on width
            const libraryWidth = libraryPanel.getBoundingClientRect().width;
            const bookWidth = bookPanel.getBoundingClientRect().width;

            if (libraryWidth < 150) {
                libraryPanel.classList.add('minimized');
            } else {
                libraryPanel.classList.remove('minimized');
            }

            if (bookWidth < 150 && bookWidth > 0) {
                bookPanel.classList.add('minimized');
            } else {
                bookPanel.classList.remove('minimized');
            }

            // Update toggle button icons/titles
            updateToggleButtons();
        }

        function updateToggleButtons() {
            const bookToggle = document.getElementById('bookPanelToggle');
            const chatToggle = document.getElementById('chatPanelToggle');

            // Book panel toggle - check if it's maximized (book-selected state and not chat-active)
            if (currentState === 'book-selected') {
                bookToggle.innerHTML = '&#x2014;'; // minimize icon (dash)
                bookToggle.title = 'Minimize';
            } else {
                bookToggle.innerHTML = '&#x26F6;'; // maximize icon
                bookToggle.title = 'Maximize';
            }

            // Chat panel toggle - check if it's maximized
            if (currentState === 'chat-active' || currentState === 'chat-active-no-book') {
                chatToggle.innerHTML = '&#x2014;'; // minimize icon
                chatToggle.title = 'Minimize';
            } else {
                chatToggle.innerHTML = '&#x26F6;'; // maximize icon
                chatToggle.title = 'Maximize';
            }
        }

        function toggleBookPanelSize() {
            if (!selectedBookId) return;

            if (currentState === 'book-selected') {
                // Currently maximized, minimize it (go to chat-active if there's context)
                if (currentBookContext) {
                    setPanelState('chat-active');
                } else {
                    setPanelState('initial');
                }
            } else {
                // Currently minimized, maximize it
                setPanelState('book-selected');
            }
        }

        function toggleChatPanelSize() {
            if (currentState === 'chat-active' || currentState === 'chat-active-no-book') {
                // Currently maximized, minimize it
                if (selectedBookId) {
                    setPanelState('book-selected');
                } else {
                    setPanelState('initial');
                }
            } else {
                // Currently minimized, maximize it
                if (currentBookContext) {
                    setPanelState('chat-active');
                } else {
                    setPanelState('chat-active-no-book');
                }
            }
        }

        function closeBookPanel() {
            selectedBookId = null;
            currentViewedBook = null;

            // Remove selection from book cards
            document.querySelectorAll('.book-card.selected').forEach(card => {
                card.classList.remove('selected');
            });

            // Reset book panel content
            document.getElementById('bookPanelContent').innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon">ðŸ“–</div>
                    <p>Select a book to view details</p>
                </div>
            `;
            document.getElementById('bookPanelTitle').textContent = 'Book Details';

            // Clear book context in chat since no book is selected
            clearBookContext();

            // Return to initial state
            setPanelState('initial');
        }

        // Book history management
        function addToBookHistory(bookId) {
            if (isNavigatingHistory) return;

            // Remove existing entry if book is already in history
            const existingIndex = bookHistory.indexOf(bookId);
            if (existingIndex !== -1) {
                bookHistory.splice(existingIndex, 1);
                // Adjust historyIndex if needed
                if (existingIndex <= historyIndex) {
                    historyIndex--;
                }
            }

            // If we're not at the end of history, remove forward history
            if (historyIndex < bookHistory.length - 1) {
                bookHistory = bookHistory.slice(0, historyIndex + 1);
            }

            // Add new book to history
            bookHistory.push(bookId);

            // Trim history if it exceeds max
            if (bookHistory.length > MAX_BOOK_HISTORY) {
                bookHistory.shift();
            }

            // Update index to point to the new entry
            historyIndex = bookHistory.length - 1;

            updateHistoryButtons();
            saveBookHistory();
        }

        function goBackInHistory() {
            if (historyIndex > 0) {
                historyIndex--;
                isNavigatingHistory = true;
                viewBook(bookHistory[historyIndex]);
                isNavigatingHistory = false;
                updateHistoryButtons();
                saveBookHistory();
            }
        }

        function goForwardInHistory() {
            if (historyIndex < bookHistory.length - 1) {
                historyIndex++;
                isNavigatingHistory = true;
                viewBook(bookHistory[historyIndex]);
                isNavigatingHistory = false;
                updateHistoryButtons();
                saveBookHistory();
            }
        }

        function updateHistoryButtons() {
            const backBtn = document.getElementById('historyBackBtn');
            const forwardBtn = document.getElementById('historyForwardBtn');

            backBtn.disabled = historyIndex <= 0;
            forwardBtn.disabled = historyIndex >= bookHistory.length - 1;
        }

        // Simple markdown rendering function
        function renderMarkdown(text) {
            if (!text) return '';
            if (typeof marked !== 'undefined') {
                return marked.parse(text);
            }
            return text
                .replace(/\n\n/g, '</p><p>')
                .replace(/\n/g, '<br>')
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.*?)\*/g, '<em>$1</em>');
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Cache for library books to avoid repeated API calls
        let libraryBooksCache = null;
        let libraryCacheTime = 0;
        const CACHE_DURATION = 30000; // 30 seconds

        async function getLibraryBooks() {
            const now = Date.now();
            if (libraryBooksCache && (now - libraryCacheTime) < CACHE_DURATION) {
                return libraryBooksCache;
            }
            try {
                const response = await fetch(`${API_BASE}/books`);
                const data = await response.json();
                libraryBooksCache = data.books;
                libraryCacheTime = now;
                return data.books;
            } catch (error) {
                console.error('Error fetching library books:', error);
                return [];
            }
        }

        // Invalidate cache when books are added/deleted
        function invalidateLibraryCache() {
            libraryBooksCache = null;
            libraryCacheTime = 0;
        }

        // Find a book in library by title (case-insensitive partial match)
        function findBookInLibrary(title, books) {
            const normalizedTitle = title.toLowerCase().trim();
            // First try exact match
            let match = books.find(b => b.title.toLowerCase() === normalizedTitle);
            if (match) return match;
            // Then try contains match
            match = books.find(b => b.title.toLowerCase().includes(normalizedTitle) ||
                                    normalizedTitle.includes(b.title.toLowerCase()));
            return match;
        }

        // Process content to make book references clickable
        async function processBookReferences(element) {
            const books = await getLibraryBooks();

            // Find all strong/bold elements (book titles are often bold in AI responses)
            const strongElements = element.querySelectorAll('strong, b, em');

            for (const el of strongElements) {
                const text = el.textContent.trim();
                // Skip short text or text that looks like labels
                if (text.length < 3 || text.endsWith(':') || /^(by|author|title|page|chapter)/i.test(text)) {
                    continue;
                }

                // Check if this looks like a book title (not a single word unless it's a known book)
                const book = findBookInLibrary(text, books);

                if (book) {
                    // Book is in library - make it clickable to view
                    el.classList.add('book-ref', 'in-library');
                    el.dataset.bookId = book.id;
                    el.dataset.bookTitle = book.title;
                    el.title = `View "${book.title}" in library`;
                    el.onclick = (e) => {
                        e.preventDefault();
                        viewBook(book.id);
                    };
                } else if (text.length > 5 && /[A-Z]/.test(text[0])) {
                    // Potential book title not in library - offer to add
                    // Only for capitalized text longer than 5 chars
                    el.classList.add('book-ref', 'not-in-library');
                    el.dataset.bookTitle = text;
                    el.title = `Add "${text}" to library`;
                    el.onclick = (e) => {
                        e.preventDefault();
                        promptAddBookFromReference(text, el);
                    };
                }
            }

            // Also look for quoted text patterns like "Book Title" or 'Book Title'
            processQuotedBookReferences(element, books);
        }

        function processQuotedBookReferences(element, books) {
            // Process text nodes to find quoted book titles
            const walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT, null, false);
            const nodesToProcess = [];

            while (walker.nextNode()) {
                const node = walker.currentNode;
                // Skip if parent is already a book-ref
                if (node.parentElement.classList.contains('book-ref')) continue;

                const text = node.textContent;
                // Match "Title" or 'Title' patterns
                const matches = text.match(/[""]([^""]+)[""]|['']([^'']+)['']|"([^"]+)"|'([^']+)'/g);
                if (matches) {
                    nodesToProcess.push({ node, matches });
                }
            }

            for (const { node, matches } of nodesToProcess) {
                let html = escapeHtml(node.textContent);

                for (const match of matches) {
                    const title = match.replace(/["'""'']/g, '').trim();
                    if (title.length < 4) continue;

                    const book = findBookInLibrary(title, books);
                    const escapedMatch = escapeHtml(match);

                    if (book) {
                        html = html.replace(
                            escapedMatch,
                            `<span class="book-ref in-library" data-book-id="${book.id}" data-book-title="${escapeHtml(book.title)}" title="View in library" onclick="viewBook(${book.id})">${escapedMatch}</span>`
                        );
                    } else if (/[A-Z]/.test(title[0])) {
                        html = html.replace(
                            escapedMatch,
                            `<span class="book-ref not-in-library" data-book-title="${escapeHtml(title)}" title="Add to library" onclick="promptAddBookFromReference('${escapeHtml(title).replace(/'/g, "\\'")}', this)">${escapedMatch}</span>`
                        );
                    }
                }

                if (html !== escapeHtml(node.textContent)) {
                    const span = document.createElement('span');
                    span.innerHTML = html;
                    node.parentNode.replaceChild(span, node);
                }
            }
        }

        // Extract author from surrounding context
        function extractAuthorFromContext(element, title) {
            // Get the parent element's text content
            const parent = element.closest('li, p, div');
            if (!parent) return null;

            const text = parent.textContent;

            // Common patterns: "Title" by Author, "Title" - Author, Title (Author)
            const patterns = [
                // "Title" by Author Name - most common
                new RegExp(`[""]?${escapeRegex(title)}[""]?\\s+by\\s+([A-Z][a-zA-Z]+(?:\\s+[A-Z][a-zA-Z]+)+)`, 'i'),
                // "Title" - Author Name
                new RegExp(`[""]?${escapeRegex(title)}[""]?\\s*[-â€“â€”]\\s*([A-Z][a-zA-Z]+(?:\\s+[A-Z][a-zA-Z]+)+)`, 'i'),
                // Title by Author (without quotes)
                new RegExp(`${escapeRegex(title)}\\s+by\\s+([A-Z][a-zA-Z]+(?:\\s+[A-Z][a-zA-Z]+)+)`, 'i'),
                // Author - "Title" pattern
                new RegExp(`([A-Z][a-zA-Z]+(?:\\s+[A-Z][a-zA-Z]+)+)\\s*[-â€“â€”]\\s*[""]?${escapeRegex(title)}[""]?`, 'i'),
            ];

            for (const pattern of patterns) {
                const match = text.match(pattern);
                if (match && match[1]) {
                    // Clean up the author name
                    let author = match[1].trim();
                    // Remove trailing punctuation or common words
                    author = author.replace(/[,.\-â€“â€”]$/, '').trim();
                    // Skip if it looks like a description word rather than name
                    if (!/^(explores|discusses|covers|about|the|a|an)$/i.test(author)) {
                        return author;
                    }
                }
            }

            return null;
        }

        function escapeRegex(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        // Flag to prevent double submission
        let isAddingBook = false;

        // Add a book from a reference, extracting author from context if possible
        async function promptAddBookFromReference(title, element) {
            // Prevent double submission
            if (isAddingBook) return;

            // Try to extract author from context first
            let author = element ? extractAuthorFromContext(element, title) : null;

            // Confirm with user before adding
            const confirmMsg = author
                ? `Add "${title}" by ${author} to your library?`
                : `Add "${title}" to your library?`;

            if (!confirm(confirmMsg)) return;

            // If we couldn't find the author, ask the user
            if (!author) {
                author = prompt(`Enter the author name for "${title}":`);
                if (!author) return;
            }

            isAddingBook = true;

            try {
                const response = await fetch(`${API_BASE}/books`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        title: title,
                        author: author,
                        status: 'want-to-read'
                    }),
                });

                const data = await response.json();

                if (response.ok) {
                    invalidateLibraryCache();
                    loadBooks();
                    loadStats();
                    // View the new book
                    if (data.id) {
                        viewBook(data.id);
                    }
                } else {
                    alert(`Error: ${data.error || 'Could not add book'}`);
                }
            } catch (error) {
                console.error('Error adding book:', error);
                alert('Error adding book. Please try again.');
            } finally {
                isAddingBook = false;
            }
        }

        async function loadStats() {
            try {
                const response = await fetch(`${API_BASE}/statistics`);
                const stats = await response.json();
                document.getElementById('stats').innerHTML = `
                    <div class="stat"><span class="stat-num">${stats.total}</span> Total</div>
                    <div class="stat"><span class="stat-num">${stats.completed}</span> Done</div>
                    <div class="stat"><span class="stat-num">${stats.reading}</span> Reading</div>
                `;
            } catch (error) {
                console.error('Error loading stats:', error);
            }
        }

        async function loadBooks() {
            try {
                const response = await fetch(`${API_BASE}/books`);
                const data = await response.json();
                displayBooks(data.books);
            } catch (error) {
                console.error('Error loading books:', error);
            }
        }

        function displayBooks(books) {
            const grid = document.getElementById('bookGrid');
            if (books.length === 0) {
                grid.innerHTML = '<p class="loading-text">No books found. Add your first book!</p>';
                return;
            }

            grid.innerHTML = books.map(book => `
                <div class="book-card ${selectedBookId === book.id ? 'selected' : ''}" onclick="viewBook(${book.id})">
                    <div class="book-cover">
                        ${book.coverUrl
                            ? `<img src="${book.coverUrl}" alt="${book.title}" loading="lazy">`
                            : `<div class="book-cover-placeholder">ðŸ“š</div>`}
                    </div>
                    <div class="book-info">
                        <h3>${escapeHtml(book.title)}</h3>
                        <p class="author">${escapeHtml(book.author)}</p>
                        <div class="bottom-row">
                            <span class="status-badge status-${book.status}">${book.status.replace(/-/g, ' ')}</span>
                        </div>
                    </div>
                </div>
            `).join('');
        }

        async function searchBooks() {
            const query = document.getElementById('searchInput').value;
            if (!query) {
                loadBooks();
                return;
            }
            try {
                const response = await fetch(`${API_BASE}/search?q=${encodeURIComponent(query)}`);
                const data = await response.json();
                displayBooks(data.books);
            } catch (error) {
                console.error('Error searching books:', error);
            }
        }

        async function viewBook(id) {
            try {
                // Update selection in grid
                document.querySelectorAll('.book-card.selected').forEach(card => {
                    card.classList.remove('selected');
                });
                // Find and select the book card (may not exist if called from history)
                const bookCard = document.querySelector(`.book-card[onclick="viewBook(${id})"]`);
                if (bookCard) {
                    bookCard.classList.add('selected');
                }

                selectedBookId = id;

                // Add to history (unless we're navigating history)
                addToBookHistory(id);

                const response = await fetch(`${API_BASE}/books/${id}`);
                const data = await response.json();
                const book = data.book;
                currentViewedBook = book;

                document.getElementById('bookPanelTitle').textContent = book.title;

                const tagsHtml = book.tags ? `
                    <div class="tags">
                        ${book.tags.split(',').map(tag => `<span class="tag">${escapeHtml(tag.trim())}</span>`).join('')}
                    </div>
                ` : '';

                document.getElementById('bookPanelContent').innerHTML = `
                    <div class="book-detail-header">
                        ${book.coverUrl ? `<img src="${book.coverUrl}" alt="${escapeHtml(book.title)}" class="book-detail-cover">` : ''}
                        <div class="book-detail-info">
                            <h2>${escapeHtml(book.title)}</h2>
                            <p><strong>Author:</strong> ${escapeHtml(book.author)}</p>
                            ${book.publishedYear ? `<p><strong>Published:</strong> ${book.publishedYear}</p>` : ''}
                            ${book.publisher ? `<p><strong>Publisher:</strong> ${escapeHtml(book.publisher)}</p>` : ''}
                            ${book.genre ? `<p><strong>Genre:</strong> ${escapeHtml(book.genre)}</p>` : ''}
                            ${book.pages ? `<p><strong>Pages:</strong> ${book.pages}</p>` : ''}
                            <p><span class="status-badge status-${book.status}">${book.status.replace(/-/g, ' ')}</span></p>
                            ${tagsHtml}
                        </div>
                    </div>
                    ${book.summary ? `
                        <div class="content-section">
                            <h3>Summary</h3>
                            <div class="markdown-content">${renderMarkdown(book.summary)}</div>
                        </div>
                    ` : ''}
                    ${book.description ? `
                        <div class="content-section">
                            <h3>Description</h3>
                            <div class="markdown-content">${renderMarkdown(book.description)}</div>
                        </div>
                    ` : ''}
                    <div id="savedQASection"></div>
                    <div class="book-actions">
                        <button class="delete-btn" onclick="deleteBook(${book.id})">Delete</button>
                    </div>
                `;

                await loadSavedQA(book.id);

                // Auto-set book context in chat panel
                await setBookContextInChat(book);

                // Show book panel
                setPanelState('book-selected');

            } catch (error) {
                console.error('Error viewing book:', error);
            }
        }

        async function setBookContextInChat(book) {
            // Only update if switching to a different book
            if (currentBookContext && currentBookContext.id === book.id) {
                return;
            }

            currentBookContext = {
                id: book.id,
                title: book.title,
                author: book.author,
                summary: book.summary || '',
                genre: book.genre || '',
                tags: book.tags || ''
            };

            showHiddenQA = false;

            // Update banner
            const banner = document.getElementById('bookContextBanner');
            banner.style.display = 'block';
            banner.innerHTML = `
                <div class="book-context-banner">
                    <span class="book-title">${escapeHtml(book.title)}</span>
                    <button onclick="clearBookContext()">Clear</button>
                </div>
            `;

            // Clear chat and load saved Q&A for this book
            document.getElementById('chatMessages').innerHTML = '';
            await loadSavedQAInChat(book.id);

            // Generate suggestions
            await generateInitialSuggestions(book.id);
        }

        async function generateInitialSuggestions(bookId = null) {
            try {
                // Fetch Q&A based on context (book or library)
                const endpoint = bookId ? `${API_BASE}/books/${bookId}/qa` : `${API_BASE}/library/qa`;
                const response = await fetch(endpoint);
                const data = await response.json();
                const savedQA = data.savedQA || [];

                // Different default suggestions for book vs library context
                const defaultSuggestions = bookId ? [
                    'What are the main themes?',
                    'Recommend similar books',
                    'Key takeaways from this book?',
                    'Who would enjoy this book?',
                    'What makes this book unique?',
                    'How does this compare to other books by the author?',
                    'What are the key arguments or ideas?',
                    'Is this book worth reading?'
                ] : [
                    'What should I read next?',
                    'Show my reading statistics',
                    'Recommend books based on my history',
                    'What genres do I read most?',
                    'Find books similar to ones I completed',
                    'What books are in my want-to-read list?',
                    'Summarize my reading habits',
                    'Which books have I been reading the longest?'
                ];

                const askedQuestions = savedQA.map(qa => qa.question.toLowerCase().trim());

                const availableSuggestions = defaultSuggestions.filter(suggestion => {
                    const normalizedSuggestion = suggestion.toLowerCase().trim();
                    return !askedQuestions.some(asked => {
                        const suggestionWords = normalizedSuggestion.split(/\s+/);
                        const matchCount = suggestionWords.filter(word =>
                            word.length > 3 && asked.includes(word)
                        ).length;
                        return matchCount >= 2 || asked.includes(normalizedSuggestion) || normalizedSuggestion.includes(asked);
                    });
                });

                const suggestionsToShow = availableSuggestions.slice(0, 3);

                if (suggestionsToShow.length > 0) {
                    showSuggestions(suggestionsToShow);
                } else if (savedQA.length > 0) {
                    const fallbackSuggestions = bookId ? [
                        'What did I miss about this book?',
                        'Deeper analysis of the themes',
                        'How does this relate to current events?'
                    ] : [
                        'Any new book recommendations?',
                        'What should be my next read?',
                        'Analyze my reading patterns'
                    ];
                    showSuggestions(fallbackSuggestions);
                } else {
                    showSuggestions(defaultSuggestions.slice(0, 3));
                }
            } catch (error) {
                console.error('Error generating suggestions:', error);
                const fallback = bookId ? [
                    'What are the main themes?',
                    'Recommend similar books',
                    'Key takeaways from this book?'
                ] : [
                    'What should I read next?',
                    'Show my reading statistics',
                    'Recommend books based on my history'
                ];
                showSuggestions(fallback);
            }
        }

        async function loadSavedQAInChat(bookId = null) {
            try {
                const includeHidden = showHiddenQA ? 'true' : 'false';
                const endpoint = bookId
                    ? `${API_BASE}/books/${bookId}/qa?includeHidden=${includeHidden}`
                    : `${API_BASE}/library/qa?includeHidden=${includeHidden}`;
                const response = await fetch(endpoint);
                const data = await response.json();
                const savedQA = data.savedQA || [];
                const hiddenCount = data.hiddenCount || 0;

                updateHiddenToggle(hiddenCount, bookId);

                const messagesDiv = document.getElementById('chatMessages');

                const elementsToRemove = messagesDiv.querySelectorAll('.saved-qa-separator, .qa-item, .qa-container');
                elementsToRemove.forEach(el => el.remove());

                if (savedQA.length > 0) {
                    const separatorDiv = document.createElement('div');
                    separatorDiv.className = 'saved-qa-separator';
                    separatorDiv.innerHTML = `<span>Previously asked (${savedQA.length})</span>`;
                    messagesDiv.appendChild(separatorDiv);

                    const qaContainer = document.createElement('div');
                    qaContainer.className = 'qa-container';
                    separatorDiv.after(qaContainer);

                    savedQA.forEach((qa, index) => {
                        const isHidden = qa.hidden === true;

                        const qaItem = document.createElement('div');
                        qaItem.className = `qa-item${isHidden ? ' hidden-qa' : ''}`;
                        qaItem.dataset.qaId = qa.id;

                        const header = document.createElement('div');
                        header.className = 'qa-header';
                        header.onclick = () => toggleQAExpand(qaItem);
                        header.innerHTML = `
                            <span class="expand-icon">â–¶</span>
                            <span class="question-text">${escapeHtml(qa.question)}</span>
                        `;

                        const body = document.createElement('div');
                        body.className = 'qa-body';
                        body.innerHTML = renderMarkdown(qa.answer);
                        // Process book references (async, but we don't need to wait)
                        processBookReferences(body);

                        const actions = document.createElement('div');
                        actions.className = 'qa-actions';
                        if (isHidden) {
                            actions.innerHTML = `
                                <button class="unhide-btn" onclick="event.stopPropagation(); unhideQA(${qa.id}, ${bookId})">Unhide</button>
                                <button class="delete-btn" onclick="event.stopPropagation(); deleteQAFromChat(${qa.id}, ${bookId})">Delete</button>
                            `;
                        } else {
                            actions.innerHTML = `
                                <button class="hide-btn" onclick="event.stopPropagation(); hideQA(${qa.id}, ${bookId})">Hide</button>
                                <button class="delete-btn" onclick="event.stopPropagation(); deleteQAFromChat(${qa.id}, ${bookId})">Delete</button>
                            `;
                        }
                        body.appendChild(actions);

                        qaItem.appendChild(header);
                        qaItem.appendChild(body);
                        qaContainer.appendChild(qaItem);
                    });
                }

                messagesDiv.scrollTop = messagesDiv.scrollHeight;
            } catch (error) {
                console.error('Error loading saved Q&A in chat:', error);
            }
        }

        function toggleQAExpand(qaItem) {
            const wasExpanded = qaItem.classList.contains('expanded');

            document.querySelectorAll('.qa-item.expanded').forEach(item => {
                item.classList.remove('expanded');
            });

            if (!wasExpanded) {
                qaItem.classList.add('expanded');
                qaItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }

        function updateHiddenToggle(hiddenCount, bookId = null) {
            const container = document.getElementById('hiddenToggleContainer');
            if (hiddenCount > 0) {
                container.style.display = 'block';
                container.innerHTML = `
                    <div class="hidden-toggle">
                        <span>${hiddenCount} hidden Q&A${hiddenCount > 1 ? 's' : ''}</span>
                        <button onclick="toggleShowHidden(${bookId})">${showHiddenQA ? 'Hide them' : 'Show hidden'}</button>
                    </div>
                `;
            } else {
                container.style.display = 'none';
                container.innerHTML = '';
            }
        }

        async function toggleShowHidden(bookId = null) {
            showHiddenQA = !showHiddenQA;
            await loadSavedQAInChat(bookId);
        }

        async function hideQA(qaId, bookId = null) {
            try {
                const response = await fetch(`${API_BASE}/qa/${qaId}/hide`, { method: 'PUT' });
                if (!response.ok) {
                    console.error('Failed to hide Q&A:', response.status);
                    return;
                }
                const qaItem = document.querySelector(`.qa-item[data-qa-id="${qaId}"]`);
                if (qaItem) {
                    qaItem.remove();
                }
                const container = document.querySelector(`.message-container[data-qa-id="${qaId}"]`);
                if (container) {
                    container.remove();
                }
                await loadSavedQAInChat(bookId);
            } catch (error) {
                console.error('Error hiding Q&A:', error);
            }
        }

        async function unhideQA(qaId, bookId = null) {
            try {
                const response = await fetch(`${API_BASE}/qa/${qaId}/unhide`, { method: 'PUT' });
                if (!response.ok) {
                    console.error('Failed to unhide Q&A:', response.status);
                    return;
                }
                await loadSavedQAInChat(bookId);
            } catch (error) {
                console.error('Error unhiding Q&A:', error);
            }
        }

        async function updateHiddenCount(bookId = null) {
            try {
                const endpoint = bookId
                    ? `${API_BASE}/books/${bookId}/qa?includeHidden=true`
                    : `${API_BASE}/library/qa?includeHidden=true`;
                const response = await fetch(endpoint);
                const data = await response.json();
                updateHiddenToggle(data.hiddenCount || 0, bookId);
            } catch (error) {
                console.error('Error updating hidden count:', error);
            }
        }

        async function deleteQAFromChat(qaId, bookId = null) {
            if (!confirm('Delete this Q&A?')) return;
            try {
                const response = await fetch(`${API_BASE}/qa/${qaId}`, { method: 'DELETE' });
                if (!response.ok) {
                    console.error('Failed to delete Q&A:', response.status);
                    return;
                }
                const qaItem = document.querySelector(`.qa-item[data-qa-id="${qaId}"]`);
                if (qaItem) {
                    qaItem.remove();
                }
                const container = document.querySelector(`.message-container[data-qa-id="${qaId}"]`);
                if (container) {
                    container.remove();
                }
                await updateHiddenCount(bookId);
            } catch (error) {
                console.error('Error deleting Q&A:', error);
            }
        }

        async function loadSavedQA(bookId) {
            try {
                const response = await fetch(`${API_BASE}/books/${bookId}/qa`);
                const data = await response.json();
                const savedQA = data.savedQA || [];

                const section = document.getElementById('savedQASection');
                if (savedQA.length > 0) {
                    section.innerHTML = `
                        <div class="saved-qa-section">
                            <h3>Saved Q&A (${savedQA.length})</h3>
                            <div class="qa-container">
                                ${savedQA.map(qa => `
                                    <div class="qa-item" data-qa-id="${qa.id}">
                                        <div class="qa-header" onclick="toggleQAExpand(this.parentElement)">
                                            <span class="expand-icon">â–¶</span>
                                            <span class="question-text">${escapeHtml(qa.question)}</span>
                                        </div>
                                        <div class="qa-body">
                                            ${renderMarkdown(qa.answer)}
                                            <div class="qa-actions">
                                                <button class="delete-btn" onclick="event.stopPropagation(); deleteSavedQA(${qa.id}, ${bookId})">Delete</button>
                                            </div>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    `;
                    // Process book references in saved Q&A
                    section.querySelectorAll('.qa-body').forEach(body => processBookReferences(body));
                } else {
                    section.innerHTML = '';
                }
            } catch (error) {
                console.error('Error loading saved Q&A:', error);
            }
        }

        async function deleteSavedQA(qaId, bookId) {
            if (!confirm('Delete this saved Q&A?')) return;
            try {
                await fetch(`${API_BASE}/qa/${qaId}`, { method: 'DELETE' });
                await loadSavedQA(bookId);
            } catch (error) {
                console.error('Error deleting Q&A:', error);
            }
        }

        async function deleteBook(id) {
            if (!confirm('Delete this book?')) return;
            try {
                const response = await fetch(`${API_BASE}/books/${id}`, { method: 'DELETE' });
                if (response.ok) {
                    closeBookPanel();
                    loadBooks();
                    loadStats();
                    loadFilters();

                    // Clear book context if this was the active book
                    if (currentBookContext && currentBookContext.id === id) {
                        clearBookContext();
                    }
                }
            } catch (error) {
                console.error('Error deleting book:', error);
            }
        }

        async function addBook() {
            const book = {
                title: document.getElementById('title').value,
                author: document.getElementById('author').value,
                isbn: document.getElementById('isbn').value,
                status: document.getElementById('status').value,
                tags: document.getElementById('tags').value,
                fetchMetadata: true,
            };

            if (!book.title || !book.author) {
                alert('Title and Author are required!');
                return;
            }

            const statusDiv = document.getElementById('addBookStatus');
            statusDiv.innerHTML = 'Fetching metadata...';

            try {
                await fetch(`${API_BASE}/books`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(book),
                });

                statusDiv.innerHTML = 'Book added!';
                setTimeout(() => {
                    closeModal('addBookModal');
                    loadBooks();
                    loadStats();
                    loadFilters();
                    document.getElementById('title').value = '';
                    document.getElementById('author').value = '';
                    document.getElementById('isbn').value = '';
                    document.getElementById('tags').value = '';
                    statusDiv.innerHTML = '';
                }, 800);
            } catch (error) {
                statusDiv.innerHTML = 'Error adding book';
            }
        }

        async function clearBookContext() {
            currentBookContext = null;
            showHiddenQA = false;

            // Show library context banner
            const banner = document.getElementById('bookContextBanner');
            banner.style.display = 'block';
            banner.innerHTML = `
                <div class="book-context-banner" style="background: linear-gradient(135deg, #28a745 0%, #20c997 100%);">
                    <span class="book-title">Library</span>
                </div>
            `;

            // Load library Q&A and suggestions
            document.getElementById('chatMessages').innerHTML = '';
            await loadSavedQAInChat(null);
            await generateInitialSuggestions(null);

            // Return to appropriate state
            if (selectedBookId) {
                setPanelState('book-selected');
            } else {
                setPanelState('initial');
            }
        }

        function showSuggestions(suggestions) {
            const container = document.getElementById('suggestionsContainer');
            if (suggestions && suggestions.length > 0) {
                container.innerHTML = `
                    <div class="suggestions-container">
                        <h4>Try asking:</h4>
                        ${suggestions.map(s => `<button class="suggestion-btn" onclick="useSuggestion('${s.replace(/'/g, "\\'")}')">${escapeHtml(s)}</button>`).join('')}
                    </div>
                `;
            } else {
                container.innerHTML = '';
            }
        }

        function useSuggestion(text) {
            if (isProcessing) return;
            document.getElementById('chatInput').value = text;
            sendMessage();
        }

        async function sendMessage(retryMessage = null) {
            const input = document.getElementById('chatInput');
            const sendBtn = document.querySelector('.chat-input button');
            const message = retryMessage || input.value.trim();
            if (!message || isProcessing) return;

            isProcessing = true;
            sendBtn.disabled = true;
            sendBtn.textContent = '...';

            // Expand chat panel when sending a message
            if (currentBookContext) {
                setPanelState('chat-active');
            } else {
                setPanelState('chat-active-no-book');
            }

            if (!retryMessage) {
                lastQuestion = message;
                addChatMessage('user', message);
                input.value = '';
            }
            document.getElementById('suggestionsContainer').innerHTML = '';

            const loadingId = showLoadingMessage();

            try {
                const requestBody = { message };
                if (currentBookContext) {
                    requestBody.bookContext = currentBookContext;
                }

                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 60000);

                const response = await fetch(`${API_BASE}/ai/query`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody),
                    signal: controller.signal
                });

                clearTimeout(timeoutId);

                if (!response.ok) {
                    throw new Error(`Server error: ${response.status}`);
                }

                const data = await response.json();

                removeLoadingMessage(loadingId);

                if (data.error) {
                    throw new Error(data.error);
                }

                lastAnswer = data.message;
                const messageContainer = await addChatMessage('assistant', data.message);

                // Auto-save Q&A for both book and library context
                if (lastQuestion && lastAnswer) {
                    const savedId = await autoSaveQA(data.suggestions);
                    if (savedId && messageContainer) {
                        const contextId = currentBookContext ? currentBookContext.id : null;
                        addControlsToMessage(messageContainer, savedId, contextId);
                    }
                }

                if (data.suggestions && data.suggestions.length > 0) {
                    showSuggestions(data.suggestions);
                }
            } catch (error) {
                console.error('Error sending message:', error);
                removeLoadingMessage(loadingId);

                let errorMsg = 'Something went wrong. ';
                if (error.name === 'AbortError') {
                    errorMsg = 'Request timed out. ';
                } else if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                    errorMsg = 'Network error. ';
                } else if (error.message.includes('Server error')) {
                    errorMsg = 'Server error. ';
                }

                showErrorMessage(errorMsg, message);
            } finally {
                isProcessing = false;
                sendBtn.disabled = false;
                sendBtn.textContent = 'Send';
            }
        }

        function showLoadingMessage() {
            const messagesDiv = document.getElementById('chatMessages');
            const loadingDiv = document.createElement('div');
            const loadingId = 'loading-' + Date.now();
            loadingDiv.id = loadingId;
            loadingDiv.className = 'message loading';
            loadingDiv.innerHTML = `
                <div class="typing-indicator">
                    <span></span><span></span><span></span>
                </div>
                <span>Thinking...</span>
            `;
            messagesDiv.appendChild(loadingDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
            return loadingId;
        }

        function removeLoadingMessage(loadingId) {
            const loadingDiv = document.getElementById(loadingId);
            if (loadingDiv) {
                loadingDiv.remove();
            }
        }

        function showErrorMessage(errorMsg, originalMessage) {
            const messagesDiv = document.getElementById('chatMessages');
            const errorDiv = document.createElement('div');
            errorDiv.className = 'message error';
            errorDiv.innerHTML = `
                <span>${escapeHtml(errorMsg)}</span>
                <button class="retry-btn" onclick="retryLastMessage('${originalMessage.replace(/'/g, "\\'")}')">Retry</button>
            `;
            messagesDiv.appendChild(errorDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        function retryLastMessage(message) {
            const errorMessages = document.querySelectorAll('.message.error');
            errorMessages.forEach(el => el.remove());
            sendMessage(message);
        }

        async function addChatMessage(role, content) {
            const messagesDiv = document.getElementById('chatMessages');
            const containerDiv = document.createElement('div');
            containerDiv.className = 'message-container';

            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${role}`;

            if (role === 'assistant') {
                messageDiv.innerHTML = renderMarkdown(content);
                // Process book references to make them clickable
                await processBookReferences(messageDiv);
            } else {
                messageDiv.textContent = content;
            }

            containerDiv.appendChild(messageDiv);
            messagesDiv.appendChild(containerDiv);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
            return containerDiv;
        }

        function addControlsToMessage(containerDiv, qaId, bookId = null) {
            containerDiv.dataset.qaId = qaId;
            const controls = document.createElement('div');
            controls.className = 'qa-controls';
            controls.innerHTML = `
                <button class="hide-btn" onclick="hideQA(${qaId}, ${bookId})">Hide</button>
                <button class="delete-btn" onclick="deleteQAFromChat(${qaId}, ${bookId})">Delete</button>
            `;
            containerDiv.appendChild(controls);
        }

        async function autoSaveQA(suggestions) {
            if (!lastQuestion || !lastAnswer) {
                return null;
            }

            try {
                // Save to book or library endpoint based on context
                const endpoint = currentBookContext
                    ? `${API_BASE}/books/${currentBookContext.id}/qa`
                    : `${API_BASE}/library/qa`;

                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        question: lastQuestion,
                        answer: lastAnswer,
                        suggestions: suggestions ? JSON.stringify(suggestions) : null,
                    }),
                });
                const data = await response.json();
                lastSavedQAId = data.id;
                return data.id;
            } catch (error) {
                console.error('Error auto-saving Q&A:', error);
                return null;
            }
        }

        function handleChatKeyPress(event) {
            if (event.key === 'Enter' && !isProcessing) sendMessage();
        }

        function showAddBookModal() {
            document.getElementById('addBookModal').classList.add('active');
        }

        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('active');
        }

        async function loadFilters() {
            // Load taxonomy for genre dropdown
            await loadTaxonomy();
        }

        // ==================== Taxonomy Functions ====================

        async function loadTaxonomy() {
            try {
                const response = await fetch(`${API_BASE}/taxonomy`);
                const data = await response.json();
                currentTaxonomy = data.taxonomy || [];
                renderGenreDropdown();
            } catch (error) {
                console.error('Error loading taxonomy:', error);
            }
        }

        function renderGenreDropdown() {
            const tree = document.getElementById('genreTree');
            const allOption = '<div class="genre-tree-all" onclick="selectGenre(null, null, \'All Genres\')">All Genres</div>';

            const genresHtml = currentTaxonomy.map(genre => `
                <div class="genre-tree-item" data-genre-id="${genre.id}">
                    <div class="genre-tree-header" onclick="toggleGenreExpand(this.parentElement, event)">
                        <span>${escapeHtml(genre.genreName)}</span>
                        <span class="expand-arrow">â–¶</span>
                    </div>
                    <div class="genre-tree-subgenres">
                        <div class="genre-tree-subgenre" onclick="selectGenre(${JSON.stringify(genre.subGenres).replace(/"/g, '&quot;')}, null, '${escapeHtml(genre.genreName)}')">
                            All ${escapeHtml(genre.genreName)}
                        </div>
                        ${genre.subGenres.map(tag => `
                            <div class="genre-tree-subgenre" onclick="selectGenre(['${escapeHtml(tag)}'], '${escapeHtml(tag)}', '${escapeHtml(tag)}')">${escapeHtml(tag)}</div>
                        `).join('')}
                    </div>
                </div>
            `).join('');

            tree.innerHTML = allOption + genresHtml;
        }

        function toggleGenreDropdown(event) {
            event.stopPropagation();
            const tree = document.getElementById('genreTree');
            tree.classList.toggle('open');

            // Close dropdown when clicking outside
            if (tree.classList.contains('open')) {
                setTimeout(() => {
                    document.addEventListener('click', closeGenreDropdownOnClickOutside);
                }, 0);
            }
        }

        function closeGenreDropdownOnClickOutside(event) {
            const tree = document.getElementById('genreTree');
            const container = document.querySelector('.genre-dropdown-container');
            if (!container.contains(event.target)) {
                tree.classList.remove('open');
                document.removeEventListener('click', closeGenreDropdownOnClickOutside);
            }
        }

        function toggleGenreExpand(item, event) {
            event.stopPropagation();
            item.classList.toggle('expanded');
        }

        function selectGenre(tags, singleTag, label) {
            selectedGenreTags = tags || [];
            selectedGenreLabel = label;
            document.getElementById('genreDropdownLabel').textContent = label;
            document.getElementById('genreTree').classList.remove('open');
            document.removeEventListener('click', closeGenreDropdownOnClickOutside);
            applyFilters();
        }

        async function applyFilters() {
            const status = document.getElementById('filterStatus').value;
            const sortValue = document.getElementById('sortBy').value;
            // Parse combined sort value (e.g., "publishedYear-desc" -> sortBy="publishedYear", sortOrder="desc")
            const lastDashIndex = sortValue.lastIndexOf('-');
            const sortBy = sortValue.substring(0, lastDashIndex);
            const sortOrder = sortValue.substring(lastDashIndex + 1);

            try {
                let books;

                // If filtering by tags, use the tags endpoint
                if (selectedGenreTags.length > 0) {
                    const tagsParam = selectedGenreTags.join(',');
                    const response = await fetch(`${API_BASE}/books/by-tags?tags=${encodeURIComponent(tagsParam)}`);
                    const data = await response.json();
                    books = data.books;

                    // Apply status filter client-side
                    if (status) {
                        books = books.filter(b => b.status === status);
                    }

                    // Apply sorting client-side
                    books.sort((a, b) => {
                        let aVal = a[sortBy] || '';
                        let bVal = b[sortBy] || '';
                        if (sortBy === 'dateAdded' || sortBy === 'publishedYear') {
                            aVal = sortBy === 'publishedYear' ? (aVal || 0) : new Date(aVal).getTime();
                            bVal = sortBy === 'publishedYear' ? (bVal || 0) : new Date(bVal).getTime();
                        }
                        const cmp = aVal > bVal ? 1 : aVal < bVal ? -1 : 0;
                        return sortOrder === 'desc' ? -cmp : cmp;
                    });
                } else {
                    // No tag filter, use standard endpoint
                    const params = new URLSearchParams();
                    if (status) params.append('status', status);
                    if (sortBy) params.append('sortBy', sortBy);
                    if (sortOrder) params.append('sortOrder', sortOrder);

                    const response = await fetch(`${API_BASE}/books?${params.toString()}`);
                    const data = await response.json();
                    books = data.books;
                }

                displayBooks(books);
            } catch (error) {
                console.error('Error applying filters:', error);
            }
        }

        // ==================== Settings Functions ====================

        function openSettings() {
            document.getElementById('settingsModal').classList.add('active');
            renderTaxonomyEditor();
        }

        function closeSettings() {
            document.getElementById('settingsModal').classList.remove('active');
        }

        function renderTaxonomyEditor() {
            const editor = document.getElementById('taxonomyEditor');

            if (currentTaxonomy.length === 0) {
                editor.innerHTML = '<p style="padding: 12px; color: #888; font-size: 12px;">No genres defined. Click "Reset to Auto-Generated" to create taxonomy from your book tags.</p>';
                return;
            }

            editor.innerHTML = currentTaxonomy.map(genre => `
                <div class="taxonomy-genre" data-genre-id="${genre.id}">
                    <div class="taxonomy-genre-header" onclick="toggleTaxonomyGenre(this.parentElement)">
                        <span class="taxonomy-genre-name">${escapeHtml(genre.genreName)}</span>
                        <div class="taxonomy-genre-actions">
                            <button onclick="event.stopPropagation(); editGenreName(${genre.id})">Rename</button>
                            <button class="delete-btn" onclick="event.stopPropagation(); deleteGenre(${genre.id})">Delete</button>
                        </div>
                    </div>
                    <div class="taxonomy-subgenres">
                        ${genre.subGenres.map(tag => `
                            <span class="taxonomy-subgenre-tag">
                                ${escapeHtml(tag)}
                                <button class="remove-btn" onclick="removeSubgenre(${genre.id}, '${escapeHtml(tag)}')">&times;</button>
                            </span>
                        `).join('')}
                    </div>
                    <div class="taxonomy-add-subgenre" style="display: none;">
                        <input type="text" placeholder="Add tag..." onkeypress="if(event.key==='Enter') addSubgenreFromInput(${genre.id}, this)">
                        <button class="small" onclick="addSubgenreFromInput(${genre.id}, this.previousElementSibling)">Add</button>
                    </div>
                </div>
            `).join('');
        }

        function toggleTaxonomyGenre(genreEl) {
            const wasExpanded = genreEl.classList.contains('expanded');
            // Close all
            document.querySelectorAll('.taxonomy-genre.expanded').forEach(el => {
                el.classList.remove('expanded');
                el.querySelector('.taxonomy-add-subgenre').style.display = 'none';
            });
            // Toggle this one
            if (!wasExpanded) {
                genreEl.classList.add('expanded');
                genreEl.querySelector('.taxonomy-add-subgenre').style.display = 'flex';
            }
        }

        async function editGenreName(genreId) {
            const genre = currentTaxonomy.find(g => g.id === genreId);
            if (!genre) return;

            const newName = prompt('Enter new genre name:', genre.genreName);
            if (!newName || newName === genre.genreName) return;

            try {
                await fetch(`${API_BASE}/taxonomy/genre/${genreId}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ genreName: newName })
                });
                await loadTaxonomy();
                renderTaxonomyEditor();
            } catch (error) {
                console.error('Error renaming genre:', error);
                alert('Error renaming genre');
            }
        }

        async function deleteGenre(genreId) {
            if (!confirm('Delete this genre?')) return;

            try {
                await fetch(`${API_BASE}/taxonomy/genre/${genreId}`, { method: 'DELETE' });
                await loadTaxonomy();
                renderTaxonomyEditor();
            } catch (error) {
                console.error('Error deleting genre:', error);
                alert('Error deleting genre');
            }
        }

        async function removeSubgenre(genreId, tag) {
            const genre = currentTaxonomy.find(g => g.id === genreId);
            if (!genre) return;

            const newSubgenres = genre.subGenres.filter(t => t !== tag);

            try {
                await fetch(`${API_BASE}/taxonomy/genre/${genreId}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ subGenres: newSubgenres })
                });
                await loadTaxonomy();
                renderTaxonomyEditor();
            } catch (error) {
                console.error('Error removing subgenre:', error);
            }
        }

        async function addSubgenreFromInput(genreId, input) {
            const tag = input.value.trim().toLowerCase();
            if (!tag) return;

            const genre = currentTaxonomy.find(g => g.id === genreId);
            if (!genre) return;

            if (genre.subGenres.includes(tag)) {
                alert('This tag already exists in this genre');
                return;
            }

            if (genre.subGenres.length >= 6) {
                alert('Maximum 6 sub-genres per genre');
                return;
            }

            const newSubgenres = [...genre.subGenres, tag];

            try {
                await fetch(`${API_BASE}/taxonomy/genre/${genreId}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ subGenres: newSubgenres })
                });
                input.value = '';
                await loadTaxonomy();
                renderTaxonomyEditor();
                // Re-expand the genre
                const genreEl = document.querySelector(`.taxonomy-genre[data-genre-id="${genreId}"]`);
                if (genreEl) {
                    genreEl.classList.add('expanded');
                    genreEl.querySelector('.taxonomy-add-subgenre').style.display = 'flex';
                }
            } catch (error) {
                console.error('Error adding subgenre:', error);
            }
        }

        async function addNewGenre() {
            if (currentTaxonomy.length >= 6) {
                alert('Maximum 6 genres allowed');
                return;
            }

            const name = prompt('Enter genre name:');
            if (!name) return;

            try {
                await fetch(`${API_BASE}/taxonomy/genre`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ genreName: name, subGenres: [] })
                });
                await loadTaxonomy();
                renderTaxonomyEditor();
            } catch (error) {
                console.error('Error adding genre:', error);
                alert('Error adding genre');
            }
        }

        async function regenerateTaxonomy() {
            if (!confirm('This will replace your current taxonomy with auto-generated genres based on your book tags. Continue?')) {
                return;
            }

            try {
                const response = await fetch(`${API_BASE}/taxonomy/generate`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ minFrequency: 1 })
                });
                const data = await response.json();
                currentTaxonomy = data.taxonomy || [];
                renderTaxonomyEditor();
                renderGenreDropdown();
                alert('Taxonomy regenerated successfully!');
            } catch (error) {
                console.error('Error regenerating taxonomy:', error);
                alert('Error regenerating taxonomy');
            }
        }

        // Handle window resize to update minimization
        window.addEventListener('resize', () => {
            setTimeout(updatePanelMinimization, 350);
        });

        // Also update after transitions
        document.getElementById('appContainer').addEventListener('transitionend', updatePanelMinimization);

        // Initialize library context in chat
        async function initializeLibraryContext() {
            const banner = document.getElementById('bookContextBanner');
            banner.style.display = 'block';
            banner.innerHTML = `
                <div class="book-context-banner" style="background: linear-gradient(135deg, #28a745 0%, #20c997 100%);">
                    <span class="book-title">Library</span>
                </div>
            `;
            document.getElementById('chatMessages').innerHTML = '';
            await loadSavedQAInChat(null);
            await generateInitialSuggestions(null);
        }

        // Initialize
        loadStats();
        loadBooks();
        loadFilters();
        loadBookHistory();
        initializeLibraryContext();
    </script>
</body>
</html>
